# 시스템

- 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법

## 시스템 제작과 시스템 사용을 분리하라

- 초기화 지연 (혹은 계산 지연)
    
    ```java
    public Service getService() {
    	if (service == null) {
    		service = new MyServiceImpl(...);
    	}
    	return service;
    }
    ```
    
    - 장점
        - 실제로 필요할 때까지 객체를 생성하지 않아 불필요한 부하가 걸리지 않으면서 애플리케이션을 시작하는 시간으 빨라진다.
        - 어떤 경우에도 null 포인터를 반환하지 않는다.
    - 단점
        - getService() 메서드가 MyServiceImpl과 생성자 인수에 명시적으로 의존한다.
        - 단위 테스트에서 getService() 메서드를 호출하기 전에 적절한 테스트 전용 객체를 필드에 할당해야 한다.
        - service 필드 값이 null일 때는 객체의 생성 책임을 추가로 갖게되면서 단일 책임 원칙이 깨진다.
        - MyServiceImpl이 모든 상황에 적합한 객체가 아닐 수 있다.

- 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.

### Main 분리

- 생성과 관련한 코드를 분리하여 생성된 객체를 사용하는 코드에서는 모든 객체가 적절히 생성되어 의존성이 연결되었다고 가정하며 그저 사용하기만 한다.
- 의존성 방향이 main 에서 애플리케이션으로 향한다.


### 팩토리

- 필요한 객체의 생성 시점을 애플리케이션에서 결정하지만, 해당 객체의 생성 코드는 애플리케이션이 모른다.
- 여기서도 마찬가지로 모든 의존성 방향이 main에서 애플리케이션으로 향한다.
    - 추상 팩토리 패턴을 사용해서 객체의 생성 시점을 결정하고, 실제 구현체는 분리한다.

### 의존성 주입 (DI)

- DI는 제어 역전(IoC) 기법을 의존성 관리에 적용한 매커니즘이다.
- 의존성을 인스턴스로 만드는 책임을 수행할 메커니즘으로 main 루틴 혹은 특수 컨테이너를 사용한다.

- JNDI 검색은 디렉터리 서버에서 이름을 검색하여 주입받는다.
- 진정한 의존성 주입은 setter 메서드나 생성자를 통해 의존성을 주입받도록 설정 파일에 지정하거나 특수 생성 모듈에서 코드로 명시한다.

## 확장

- 점진적인 애자일 방식으로 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.
- 이를 위해서 TDD, 리팩터링 등으로 코드를 깨끗하게 하면 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

- 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

## 횡단 관심사

- 특정 관심사를 구현한 코드가 온갖 객체로 흩어질 수 있다. 이를 횡단 관심사라 한다.
- 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론은 관점 지향 프로그래밍(AOP) 이다.
    - 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.

## 자바 프록시

- 개별 객체나 클래스에서 메서드 호출을 감싸는 경우에 사용된다.
- 코드 양과 크기가 크다는 것이 단점이다.
- 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않는다.

- 프록시 패턴
    - Lazy loading
        - 인터페이스의 일반 구현체에는 필요한 비즈니스 로직을 작성
        - 프록시 구현체에는 최소 정보만을 가지고 비즈니스 로직의 실제 사용 시에 일반 구현체의 메서드를 호출하도록 구현
    - Dynamic proxy
        - InvocationHandler의 구현체를 만들어 리플랙션을 활용하여 호출된 메서드의 동작을 확장
        - Java.lang.reflect.Proxy 클래스의 newProxyInstance() 메서드를 활용하여 프록시 객체를 선언
    - Remote proxy
        - 프록시 클래스를 로컬에 두고 실제 클래스를 remote하도록 하여 데이터를 효율적으로 공유
        - 예시) 온라인 게임에서 내가 캐릭터를 이동한다면 프록시 객체를 이동한 것이고, 이를 서비스 보조 객체가 실제 캐릭터 객체에 요청을 보내 이동하는 것이다.
    - https://velog.io/@cv_/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

## 순수 자바 AOP 프레임워크

- 여러 자바 프레임워크(Spring AOP 등)는 내부적으로 프록시를 사용한다.
- POJO는 순수하게 도메인에 초점을 맞추어 테스트가 개념적으로 더 쉽고 간단하다.
- 클라이언트는 인터페이스가 되는 객체에서 원하는 메서드를 호출한다고 생각하지만, 
실제로는 중첩 데코레이터 객체 집합의 가장 외곽과 통신한다.
- 애너테이션을 활용하여 순수한 POJO만을 구현하도록 하여 코드를 테스트하고 보수하기 쉬워진다.

## AspectJ 관점

- 관심사를 관점으로 분리하는 가장 강력한 도구이다.
- 애너테이션 폼을 통해 AspectJ에 미숙한 팀들이 애너테이션 기반 관점을 쉽게 사용할 수 있도록 기능을 제공한다.

## 테스트 주도 시스템 아키텍처 구축

- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빠르게 출시한 후, 기반 구조를 추가하여 조금씩 확장해도 괜찮다.
- 최선의 시스템 구조는 각기 PQJO(또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다

## 의사 결정을 최적화하라

- 관심사를 모듈로 분리한 PQJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 표준이 좋은 점은 많다. 하지만 때로는 표준을 만드는 시간이 오래걸리거나 표준을 제정한 목적을 잊기도 한다.

## 시스템 도메인 특화 언어가 필요하다

- 도메인 특화 언어(DSL)를 사용하면 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.

## 결론

- 시스템 역시 깨끗해야 한다.
- 깨끗하지 못하면 도메인 논리를 흐리며 기민성을 떨어뜨리고 제품 품질이 떨어지며, 버그가 많아질 수 있고 생산성이 낮아진다.
- 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 이를 위해서 POJO를 작성하고 관심사를 분리해야 한다.
- **모든 설계는 실제로 돌아가는 가장 단순한 수단을 사용해야 한다!**