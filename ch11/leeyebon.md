# 시스템의 설정논리와 실행 논리 분리

제작과 사용을 분리해서 사용하라

설계 단계에서 가장 먼저 하는 단계는 관심사 분리이다.

초기화 지연 기법을 사용하면 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하를 줄일 수 있지만 실행 메서드가 생성 객체 인수에 명시적으로 의존해 컴파일 오류가 발생할 수 있다.

## Main 분리

- 애플리케이션의 진입점인 main() 메서드는 실행 흐름과 객체 생성(설정 로직)을 담당하지만, 핵심 비즈니스 로직과는 분리되어야 한다.
- main()은 오직 설정(객체 조립, 환경 구성 등)만 하고, 실제 로직은 별도 클래스로 위임하는 구조가 바람직하다.
- 이를 통해 프로덕션 코드와 설정/초기화 코드를 명확히 분리할 수 있으며, 테스트 및 유지보수가 쉬워진다.

## 팩토리

- 객체 생성 로직을 별도의 클래스(또는 메서드)로 위임해, 객체 사용과 생성의 책임을 분리하는 패턴이다.
- 실행 시점에서 어떤 구현체를 사용할지 결정하거나, 복잡한 객체 생성 과정을 감추는 데 유용하다.
- Spring이나 DI 컨테이너에서는 내부적으로 팩토리를 통해 빈(bean)을 생성하거나, 동적으로 프록시를 구성하는 데 활용한다.
- 팩토리를 사용하면 지연 생성(lazy initialization), 다형성, 구현 교체의 유연성을 확보할 수 있다.

## 의존성 주입

- 제어 역전 기법을 의존성 관리에 적용한 메커니즘이다.
- 대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고, 대부분은 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다.

<br>

# 시스템의 확장

- 설계단계에서부터 관심사 분리가 되지 않으면 비즈니스 논리가 애플리케이션 컨테이너에 강하게 결합되는 경우가 발생한다.
- 클래스를 생성할 때는 컨테이너에서 파생해야 하며 컨테이너가 요구하는 다양한 생명주기 메서드도 제공해야 한다. → 결합도가 높아짐
- 단위 테스트가 어려워지는 것뿐만 아니라 코드 재사용과 확장이 어려워진다.

## 횡단 관심사

- 영속성, 트랜잭션, 보안 등 횡단 관심사로 모듈화할 수 있는 것들은 관점 지향 프로그래밍과 관련이 있다.
- AOP에서 관점이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다”라고 명시한다.

## 자바 프록시

- 단순한 상황에 적합한 해당 객체는 개별 객체나 클래스에서 메서드 호출을 감싸는 경우 사용된다.
- JDK에서 제공하는 동적 프록시는 인터페이스만 지원한다. 클래스 프록시를 사용하려면 CGLIB 등과 같은 바이트 코드 처리 라이브러리가 필요하다.
- 프록시를 활용하면 시스템 경계를 도메인 로직과 분리할 수 있어 추후 구현체의 변경 없이 프록시 객체를 활용하는 부분만 수정해 DB와 같은 외부 로직 변경 및 확장이 자유로워진다.
- 하지만 이러한 매핑 과정을 위해서는 코드의 양과 크기가 많아지고 커진다는 단점이 있다.

## 순수 자바 AOP 프레임워크

- Spring AOP(XML 기반)는 관점(Aspect)을 코드가 아닌 설정(XML) 으로 정의해, 핵심 비즈니스 로직과 부가 기능(트랜잭션, 로깅 등)을 분리할 수 있게 해준다.
- 프록시 객체를 자동으로 생성해, 실제 객체를 감싸고 메서드 실행 전/후로 공통 관심사를 삽입한다.
- 설정 파일(app.xml)에 의존해 스프링 코드 없이도 AOP가 적용되며, 애플리케이션은 스프링과의 결합도가 낮아진다.
- EJB2 대비 경량이고 테스트가 쉬우며, XML 설정을 통해 정책을 외부화할 수 있어 유연한 구조가 가능하다.
- 하지만 XML 설정이 장황하고 가독성이 떨어질 수 있으며, **AOP 적용 범위가 인터페이스 기반(JDK 동적 프록시)**에 국한되는 제약이 있다.

## AspectJ 관점

- 마지막으로, 관심사를 관점으로 분리하는 가장 강력한 도구이다.
- 이전의 순수 자바 방식은 관점이 필요한 상황 중 80~90%에 충분하다.
- AspectJ는 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하지만 러닝커브가 존재한다는 단점이 있다.

<br>

# 결론

- 특정 어플리케이션에 종속되지 않는다면(어노테이션 사용 없이) 코드 수준에서 아키텍처 관심사 분리가 가능해 테스트 주도 아키텍처 구축이 가능해진다.
- 설계가 최대한 분리되어 각 추상화 수준과 범위에서 코드가 적당히 단순해지면 확장이 유연해진다.
- 따라서 모듈을 나누고 관심사를 분리해 POJO 시스템을 만들면 기민하게 최적의 결정을 내릴 수 있다. → DSL과 같은 간단한 스크립트 언어로 구현한 api 활용이 커진 이유