# 함수

## 작게 만들어라!

- 켄트 벡의 코드에서는 각 함수가 이야기 하나를 표현했다.

### 블록과 들여쓰기

- if/else/while 등에 들어가는 블록은 한 줄이면 된다.
    - 그 내부는 새로운 함수로 추출 가능할 것이다.
- 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.
- 그래야 함수를 읽고 이해하기 쉬워진다.

## 한 가지만 해라!

- 함수는 한 가지를 해야 한다.
    - 그 한 가지를 잘 해야 한다.
    - 그 한 가지만을 해야 한다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면
    - 그 함수는 한 가지 작업만 한다.
    - 그 의미를 유지하면서 규모를 줄여야 한다.

## 함수 당 추상화 수준은 하나로!

- 추상화 수준을 일정하게 유지해야 한다.
- 함수 내 추상화 수준이 섞이면 코드를 읽는 사람이 헷갈린다.
- 깨어진 창문처럼 사람들이 함수에 세부 사항을 점점 더 추가한다.

### 위에서 아래로 코드 읽기 : 내려가기 규칙

- 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

## Switch 문

- 문제점
    - 함수가 길다
    - 한 가지의 작업만 수행하지 않는다.
    - SRP를 위반한다.
    - OCP를 위반한다.
    - 구조가 동일한 함수가 무한정 존재할 수 있다.
- 해결 방법
    - 다형적 객체를 생성할 때만 사용하라.
    - 불가피한 상황도 생길 수 있다…

## 서술적인 이름을 사용하라!

- 워드가 말한 원칙
    - “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.”
- 함수가 작고 단순할수록 서술적인 이름을 고르기 쉬워진다.
- 이름을 붙일 때 일관성이 있어야 한다.

## 함수 인수

- 인수는 개념을 이해하기 어렵게 만든다.
- 코드를 읽는 사람이 현 시점에서 별로 중요하지 않은 세부 사항을 알아야 할 수 있다.

```java
SetupTeardownlncluder.render(pageData)
```

- 위 코드는 PageData 객체 내용을 렌더링 하겠다는 뜻이라고 한 눈에 봐도 이해할 수 있다.

### 많이 쓰는 단항 형식

- 인수에 질문을 던지는 경우 **(조회)**
    - `boolean fileExists(”MyFile”)`
- 인수를 무언가로 변환해 결과를 반환하는 경우 **(변환/명령)**
    - `InputStream fileOpen(”MyFile”)`
- 위 두 경우를 분명히 구분하여 일관적인 방식으로 사용하라.
- 함수 형식 이벤트
    - 출력 인수가 없다.
    - `passwordAttemptFailedNtimes(int attempts)`
    - 이벤트라는 사실이 코드에 명확히 드러나야 한다.
- 입력 인수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다.
    - 반환 값이 void로 함수 내에서 그대로 출력해주는 것보다는…

### 플래그 인수

- 함수로 부울 값을 넘기면 한 함수가 여러 작업을 한다고 공표하는 셈이다.

### 이항 함수

- 무시할 필요가 있는 인수가 있을 수 있다.
    - 무시한 코드에 오류가 숨어들 수 있다.
- 하나의 값을 표현하는 두 요소라면 괜찮다.
    - ex) 좌표값 (x, y)
- `assertEquals(expected, acutal)`
    - 강제적으로 인수에 입력해야 할 순서를 기억하게 만든다는 문제점이 있다.
- 단항 함수로 바꾸도록 노력할 필요가 있다.

### 삼항 함수

- `assertEquals(message, expected, actual)`
    - 이항 함수에서는 expected가 첫 번째 인수였는데…..

### 인수 객체

- 하나의 값을 표현하는 인수들이 있을 때 객체로 만들어준다.
    - 변수를 묶어 이름을 붙여주므로 개념을 표현하게 된다.

### 인수 목록

- 가변 인수를 사용할 경우에도 동일한 원리가 적용된다.

### 동사와 키워드

- 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
    - `write(name)`
    - `writeField(name)`
- 함수 이름에 인수 이름을 넣는다.
    - `assertEquals(expected, actual)`
    - 보다는
    - `assertExcpectedEqualsActual(expected, actual)`
    - 이러면 순서를 기억할 필요가 없다.

### 부수 효과를 일으키지 마라!

- 예상치 못하게 클래스 변수를 수정하거나
    - 함수로 넘어온 인수나 시스템 전역 변수를 수정한다.
- 시간적인 결합이나 순서 종속성을 초래한다.
- 함수의 이름에 부수 효과 또한 명시하는 것이 좋다.

### 출력 인수

- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하도록 한다.
- 출력 인수는 피하자!

## 명령과 조회를 분리하라!

- 무언가를 수행하거나 답하거나 둘 중 하나만 해야 한다.
    - 객체 상태를 변경하거나
    - 객체 정보를 반환하거나

## 오류 코드보다 예외를 사용하라!

### Try/Catch 블록 뽑아내기

- 정상 동작과 오류 처리 동작이 뒤섞인다.
- 블록 내부 동작을 함수로 추출하는 것이 좋다.

### 오류 처리도 한 가지 작업이다.

### 에러 코드는 enum으로 관리되지만 예외는 재컴파일/재배치 없이도 파생된다.

## 반복하지 마라!

- 코드 길이도 늘어나지만
- 알고리즘이 변하면 반복된 모든 곳에서 손봐야 한다.

## 구조적 프로그래밍

- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
- ⇒ 큰 함수에서는 좋지만 작음 함수에서는 상관없을 수 있다.

## 함수를 어떻게 짜죠?

- 처음에는 길고 복잡하게
    - 단위 테스트와 함께
- 그 후 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
    - 단위 테스트의 성공과 함께

# 결론

- 함수는 동사며
- 클래스는 명사다
- 하나의 이야기로 생각하고 시스템을 구성하자.