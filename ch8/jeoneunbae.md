# 경계

- 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교 살피기

## 외부 코드 사용하기

- 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다.
패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다.
반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
- 한 예시로 Map 을 살펴본다.
Map 은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다.
    - 프로그램에서 Map 을 만들어 여기저기 넘긴다고 가정
    넘기는 쪽에서는 아무도 Map 을 삭제하지 않는다고 가정하지만 `clear()` 메서드를 이용하여 누구든 지울 권한이 있다.
    - 또, 설계 시 Map 에 특정 유형만 저장하기로 약속했지만 Map 은 객체 유형을 제한하지 않기에 누구든 다양한 객체 유형을 추가할 수 있다.
- `Sensor` 코드 예시
    
    ```java
    Map sensors = new HashMap();
    
    Sensor s = (Sensor) sensors.get(sensorId);
    ```
    
    - 즉, Map 이 반환하는 `Object` 를 올바른 유형으로 변환할 책임은 Map 을 사용하는 클라이언트에 있다.
    위 방식으로 작성해도 코드는 동작하지만, 깨끗한 코드라 보기는 어렵다.
    - 대신 제네릭스를 사용하면 코드 가독성이 크게 높아진다.
    
    ```java
    Map<String, Sensor> sensors = new HashMap<Sensor>();
    ...
    Sensor s = sensors.get(sensorId);
    ```
    
    - 프로그램에서 `Map<String, Sensor>` 인스턴스를 여기저기로 넘긴다면, Map 인터페이스가 변할 경우, 수정할 코드가 상당히
    많아진다.
    
    - 다음은 Map 을 좀 더 깔끔하게 사용한 코드이다.
    `Sensors` 사용자는 제네릭스가 사용되었는지 여부에 신경 쓸 필요가 없다.
        
        ```java
        public class Sensors {
        	private Map sensors = new HashMap();
        	
        	public Sensor getById(String id) {
        		return (Sensor) sensors.get(id);
        	}
        }
        ```
        
        - 경계 인터페이스인 Map 을 `Sensors` 안으로 숨긴다.
        따라서 Map 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다.
        `Sensors` 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다.
        - Map 과 같은 경계 인터페이스를 사용할 때는 클래스나 클래스 게열 밖으로 노출되지 않도록 주의한다.

## 경계 살피고 익히기

- 외부 코드를 사용하면 적은 시간 더 많은 기능을 출시할 수 있다.
하지만 외부에서 가져온 패키지를 사용한다면 어디서 어떻게 시작해야 좋을까?
외부 패키지 테스트가 우리 책임은 아니지만, 우리 자신을 위해 우리가 사용할 코드를 테스트하는 것이 바람직하다.
- 다르게 접근해서 곧바로 우리쪽 코드를 작성하여 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 우리쪽
코드를 작성해 외부 코드를 익히면 어떨까?
이를 `학습 테스트`라 부른다.
- 학습 테스트
    - 프로그램에서 사용하려는 방식대로 외부 API 를 호출한다.
    통제된 환경에서 API 를 제대로 이해하는지를 확인하는 셈이다.
    학습 테스트는 API 를 사용하려는 목적에 초점을 맞춘다.

## 학습 테스트는 공짜 이상이다

- 학습 테스트에 드는 비용은 없다. 
학습 테스트는 공짜 이상이다.
투자하는 노력보다 얻는 성과가 더 크다.
- 학습 테스트는 패키지가 예상대로 작동하는지 검증한다.
일단 통합한 이후라고 하더라도 패키지가 우리 코드와 호환된다는 보장은 없다.
언제 코드를 변경할 필요가 생길지도 모른다.
- 새 버전이 우리 코드와 호환되지 않으면 학습 테스트를 통해 이 사실을 밝혀낼 수 있다.
- 학습 테스트를 사용하던 안하던 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.
- 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.

## 아직 존재하지 않는 코드를 사용하기

- 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계이다.
때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.
- 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다.
또한 코드 가독성도 높아지고 코드 의도도 분명해진다.

## 깨끗한 경계

- 경계에 위치하는 코드는 깔끔히 분리한다.
또한 기대치를 정의하는 테스트 케이스도 작성한다.
- 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
자칫하면 오히려 외부 코드에 휘둘리고 만다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자
- Map 예시 처럼 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는
인터페이스를 패키지가 제공하는 인터페이스로 변환하자
- 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며,
외부 패키지가 변했을 때 변경할 코드도 줄어든다.
